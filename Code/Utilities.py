# -*- coding: utf-8 -*-
"""
Created on Wed Sep  4 13:53:25 2019
@author: sayon
"""

import numpy as np
import scipy as sp
from sklearn import linear_model
from sklearn import kernel_ridge
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import Axes3D
from jitcdde import jitcdde, y, t


'''=========================================================================='''
# #### Defining the Global variables
'''=========================================================================='''
ar_order_min = 1             # Minimum Ar order
ar_order_max = 15            # Maximum Ar order
step_pred_min = 1            # Minimum step ahead prediction
step_pred_max  = 40          # Maximum step ahead prediction


'''=========================================================================='''
# #### Defining the ODE equations for Lorenz attractor
'''=========================================================================='''
def lorenz(X, time_step, sigma, beta, rho):
    u, v, w = X
    up = sigma*(v - u)
    vp = u*(rho - w) - v
    wp = -beta*w + u*v
    return up, vp, wp


'''=========================================================================='''
# #### Generate data for Lorenz model with parameter: $\sigma, \beta, \rho$
# - u0, v0, w0 : Initial value
# - tmax, n: maximum time, no. of steps
'''=========================================================================='''
def generate_Lorenz_data(sigma = 10, beta = 2.667, rho = 28, u0 = 0.0, v0 = 1.0, w0 = 1.05, tmax = 100, n = 10000):
    t_step = np.linspace(0, tmax, n)
    f = odeint(lorenz, (u0, v0, w0), t_step, args=(sigma, beta, rho))
    return f.T, t_step


'''=========================================================================='''
# #### Generate data for Mackey-Glass model with parameter: $\tau, \beta, \gamma, n$
# - tmax, t_step, x0: maximum time, time step, initial value of x
'''=========================================================================='''
def generate_Mackey_data(x0 = 1.5, tau = 10, n = 5, beta = .5, gamma = .2, tmax = 10000, t_step = 10):
    f = [ beta * y(0, t - tau) / (1 + y(0, t - tau)**n) - gamma*y(0) ]
    DDE = jitcdde(f)
    DDE.constant_past([x0])
    DDE.step_on_discontinuities()
    data = []
    time_axis = np.arange(DDE.t, DDE.t + tmax, t_step)
    for time in np.arange(DDE.t, DDE.t + tmax, t_step):
        data.append( DDE.integrate(time))  
    return data, time_axis    


'''============================================================================'''
# #### Functions to display plots of the data generated by the models
'''============================================================================'''
def display_Lorenz_data(data, size = (10, 10)):
    x, y, z = data[:, 0], data[:, 1], data[:, 2]
    fig = plt.figure(figsize = size)
    ax = fig.gca(projection='3d')
    n = data.shape[0]
    s = 10
    c = np.linspace(0, 1, n)
    for i in range(0, n - s, s):
        ax.plot(x[i:i+s+1], y[i:i+s+1], z[i:i+s+1], color=(c[i], c[i], 0.0), alpha=0.9)
    return   


def display_Mackey_data(data, time_axis, size = (10, 10)):
    plt.figure(figsize = size)
    plt.plot(time_axis, data)
    plt.xlabel('time')
    plt.ylabel('y(t)')
    plt.title('Mackey-Glass model')
    return 

'''=========================================================================='''
# #### Functions for calculating performance metrics
'''=========================================================================='''
def calculate_RMSE(act, pred):
    return np.sqrt(np.mean((act - pred)**2))


def calculate_R2(act, pred):
    variance = np.var(act)
    MSE = calculate_RMSE(act, pred)**2
    return (1 - (MSE/variance))


'''=========================================================================='''
# #### Display performace metric plots
'''=========================================================================='''
def display_plot(data, size = (25, 12), metric = 'RMSE', title = 'Mackey-Glass Attractor', dst_name = 'MGD-RMSE.png', save_flg = 0):
    #Color scheme of the plot for different AR order        
    c = np.linspace(0, 1, (ar_order_max - ar_order_min + 1))
    #Plotting the result
    plt.figure(figsize=size)    
    for i in range(len(c)):
        plt.plot(np.arange(step_pred_min, (step_pred_max+1)), data[i, :], label = '$AR order = {i}$'.format(i = i + ar_order_min))
    plt.xlabel('No. of steps ahead prediction')
    plt.ylabel(metric)
    plt.title(title)    
    plt.legend()
    plt.autoscale(tight = True)
    if save_flg!=0:
        plt.savefig(dst_name)
    return   

'''=========================================================================='''
# #### Generate lag data the columns follow the schematic: [0, 1, 2, ..., N] -> [x[n-N] || x[n-(N-1)] || ...x[n-1] || x[n]]
'''=========================================================================='''
def generate_lag_k_steps_ahead_data(data, ar_ord = 15, step_pred_min = 1, step_pred_max = 50):
    data_res = data.copy()
    print(step_pred_min, step_pred_max)
    for i in range(1, ar_ord + step_pred_max):
        lag_dat = np.roll(data, i, axis = 0)
        data_res = np.concatenate((data_res, lag_dat), axis = 1)
    data_res = data_res[:, np.flip(range(data_res.shape[1]))]
    return data_res


'''=========================================================================='''
# #### Generate 1 to k-step prediction : [0, 1, 2, ..., N] -> [x[n-N] || x[n-(N-1)] || ...x[n-1] || x[n]]
'''=========================================================================='''
def generate_k_steps_ahead_prediction(data_X, reg_mdl, step_pred_max = 50, Lor_flag = 1):
    nrows, ncols = data_X.shape
    prediction = np.zeros((nrows, 1))
    for i in range(step_pred_max):
        pred_temp = reg_mdl.predict(data_X)
        prediction = np.concatenate((prediction, pred_temp), axis = 1)
        if Lor_flag == 0:
            data_X = np.roll(data_X, 1, axis = 1)
            data_X[:, 0] = pred_temp.reshape(-1)
        else:
            data_X = np.roll(data_X, 3, axis = 1)
            data_X[:, :3] = pred_temp           
    prediction = prediction[:, 1:]    
    return prediction    
